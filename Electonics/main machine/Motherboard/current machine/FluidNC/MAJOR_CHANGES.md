# Major Changes Overview

This file summarizes the key behavior changes and features you asked to document. It’s intentionally concise and focused on “how it works” and “how to use it”.

## Calibration quick start

- Tool bank (M155)
  - Send M155 to seek X+ then Y+, capture limits, map into negative-space, and persist Tool 1 plus autogenerated tools to `/spiffs/toolconfig.json`. The routine uses safe “system motion,” won’t trigger soft-limit alarms, and returns to origin.
  - Update Z later without motion using M155 Z[value] (e.g., `M155 Z-10.0`).
- Work area/origin (M156)
  - Interactive only (P required):
    - `M156 P1` — Auto-measure from max: seeks X+ then Y+ and captures max bounds.
    - `M156 P2` — Auto-measure from min: seeks X− then Y− and captures min bounds.
    - `M156 P3` — Finalize: computes origin as (max − 0.02), rounds, writes config, and restarts.

For full, step-by-step instructions and notes, see `CALIBRATION.md`.

## Tool change (M6 Tn)

- What: M6 with Tn triggers a pen/tool change to tool n.
- How: The planner executes a safe “system motion” to the configured tool position and performs the change; failure rolls back to the previous tool.
- Limits: Soft limits are coordinated via the central Limits module so pen changes don’t trip soft-limit alarms; hard limits still apply.
- State: Current tool is persisted in `/spiffs/penstate.json`.

## ATC JSON storage

- Files: `/spiffs/toolconfig.json` (tools array with number, x, y, z, occupied), `/spiffs/penstate.json` (last known tool).
- API: `/toolconfig` GET/POST, `/toolconfig/position`, `/toolconfig/status`.

## ATC calibration (M155)

- Purpose: Measure Tool 1 X/Y from positive limits, map to negative-space coordinates relative to work origin; auto-generate tools 2–6; optionally set Z.
- Use:
  - Run `M155` to perform X+/Y+ limit seeks and persist Tool 1 and the autogenerated bank.
  - Run `M155 Z-10.0` (example) later to update Tool 1 Z only (no motion).
- Behavior: Returns to work origin after calibration; writes to toolconfig JSON.

Code (parser: Z-only update without motion)

```cpp
// GCode.cpp (M155 Z-only path)
case 155:  // M155 - Tool calibration / Z update
  // If a Z word is present, update Tool 1 Z only, with NO motion.
  if (bitnum_is_true(axis_words, Z_AXIS)) {
      ToolCalibration::setToolZ(gc_block.values.xyz[Z_AXIS]);
      // Consume the Z word so it won't plan motion or trip checks
      clear_bits(value_words, bitnum_to_mask(GCodeWord::Z));
      axis_words &= ~bitnum_to_mask(Z_AXIS);
      // Keep modal grouping consistent
      mg_word_bit = ModalGroup::MM4;
  } else {
      gc_block.non_modal_command = NonModal::ToolCalibration;
      mg_word_bit                = ModalGroup::MM4;
  }
```

How it works

- Z-only path: If a Z word is present, the parser calls `ToolCalibration::setToolZ(...)`, then explicitly consumes the Z so it can’t be misinterpreted as a motion target or cause a modal violation. No planner motion is queued, so steppers won’t move.
- Full calibration path: Without Z, the parser sets `NonModal::ToolCalibration`. Execution then transitions the controller into a calibration-safe state that enables “system motion” semantics, so queued seeks can run without soft-limit prechecks.
- Limits behavior: While calibrating, limit trips are routed to `ToolCalibration::onLimit(...)` (measurement) rather than raising alarms; hard limits still stop motion if configured.
- Coordinate math: X+/Y+ limit machine positions are captured, adjusted by each axis pulloff, then mapped into negative-space relative to `work_area.origin_x|origin_y`.
- Tool bank generation: Tool 1 (measured) is persisted exactly; additional tools (2–6) are auto-generated with fixed spacing along −Y for a consistent bank layout.
- Safety and control: Planner flags ensure controlled feeds for approach vs precise moves during calibration segments; reset/abort returns to Idle and cancels system motion cleanly.

## Work area and work origin

- Config: `work_area` block in `FluidNC/data/config.yaml` with `min_x|min_y|max_x|max_y|origin_x|origin_y|enabled|move_to_origin`.
- Toggles: Work area limits can be enabled/disabled via dedicated M-codes (present in parser).
- Rounding: Values are kept to one decimal in config to avoid float residue that can trigger soft-limit edges.

## Work area calibration (M156)

- Purpose: Calibrate work origin and bounds interactively in three steps (no default full-auto).
- Use:
  - `M156 P1` to auto-seek X+/Y+ and capture max.
  - `M156 P2` to auto-seek X−/Y− and capture min.
  - `M156 P3` to compute origin (max − 0.02), persist, and restart.

Code (dispatch + start)

```cpp
// GCode.cpp (dispatch)
case 156:  // M156 - Work area calibration (origin and bounds)
  gc_block.non_modal_command = NonModal::WorkAreaCalibration;
  mg_word_bit                = ModalGroup::MM4;

// Later during non-modal execution
case NonModal::WorkAreaCalibration: {
  // P modes: 0/none = auto; 1 = capture max; 2 = capture min; 3 = finalize+save
  int mode = (int)gc_block.values.p;
  if (mode == 1)      WorkAreaCalibration::startCaptureMax();
  else if (mode == 2) WorkAreaCalibration::captureMinAtCurrent();
  else if (mode == 3) WorkAreaCalibration::finalizeAndSave();
  else                WorkAreaCalibration::start(0);
}
```

Code (compute, round to 0.1 mm, atomic write)

```cpp
// WorkAreaCalibration.cpp (core of compute/persist)
static float round3(float v) {
  // Round to 0.1mm to avoid floating artifacts like -30.19999
  return floorf(v * 10.0f + (v >= 0 ? 0.5f : -0.5f)) / 10.0f;
}

static void computeAndPersist() {
  float xPul = getPulloff(X_AXIS);
  float yPul = getPulloff(Y_AXIS);
  float origin_x = round3(-(xLimitMpos[X_AXIS] - xPul));
  float origin_y = round3(-(yLimitMpos[Y_AXIS] - yPul));
  float min_x = round3(origin_x - (xLimitMpos[X_AXIS] - startMpos[X_AXIS] - xPul));
  float min_y = round3(origin_y - (yLimitMpos[Y_AXIS] - startMpos[Y_AXIS] - yPul));
  float max_x = round3(origin_x - 0.3f);
  float max_y = round3(origin_y - 0.3f);
  writeWorkAreaToConfig(min_x, max_x, min_y, max_y, origin_x, origin_y);
}
```

How it works

- Motion flow: Starting from your reference point, the routine seeks to X+ limit first, then Y+. On each limit, it resets steppers/plan to avoid residual motion and records the machine position for that axis.
- Pulloff compensation: The stored limit machine positions are corrected by each axis’ pulloff value to reflect a safe working edge instead of the raw switch trip location.
- Negative-space math: The work origin is computed in “negative space” by negating the compensated max positions. The min bounds are derived from the travel between the start point and the measured max, preserving your chosen reference origin.
- Guard band on max: `max_x|max_y` are set slightly inside the origin (−0.3 mm) to create a soft-limit guard that avoids grazing the origin boundary during rapid moves.
- Rounding and stability: All values are rounded to 0.1 mm to eliminate floating-point residue (like −30.19999) that can otherwise cause nuisance soft-limit checks.
- Atomic config update: The routine resolves the active `config_filename`, reads the current file, rewrites the `work_area` block, writes a temporary file, then renames it to replace the original—ensuring a power-loss-safe update.
- Lifecycle and restart: After writing, the controller marks calibration done, returns to Idle, and issues a restart so the new limits and origin are active for subsequent jobs.

## Laser pointer offset

- Config: `laser_offset_x`, `laser_offset_y` in `config.yaml`.
- How it works: The parser applies a coordinate offset (not G92) so soft limits remain valid. You can temporarily disable auto-apply if needed; re-enable to restore.

Code (apply/remove offset)

```cpp
// GCode.cpp
void apply_laser_pointer_offset() {
  float x_offset = config->getLaserOffsetX();
  float y_offset = config->getLaserOffsetY();
  // Apply offsets in a way that works with soft limits
  gc_state.coord_offset[X_AXIS] = -x_offset;
  gc_state.coord_offset[Y_AXIS] = -y_offset;
  gc_ngc_changed(CoordIndex::G92);
  gc_wco_changed();
}

void remove_laser_pointer_offset() {
  clear_vector(gc_state.coord_offset);
  laser_offset_disabled = true;
  gc_ngc_changed(CoordIndex::G92);
  gc_wco_changed();
}

// Parser entries
case 150: /* set/apply */ apply_laser_pointer_offset(); break;
case 151: /* remove */    remove_laser_pointer_offset(); break;
```

How it works

- The offset values come from config (`laser_offset_x|y`) or can be set ad hoc via M150 words; they’re stored and re-applied until removed.
- Offsets are applied to the parser’s coordinate offset vector so program coordinates shift consistently without issuing explicit positioning moves that might violate soft limits.
- Removing the offset clears the vector and flips a flag that prevents auto-apply until you explicitly enable or set it again.
- Internal state notifications (`gc_ngc_changed`, `gc_wco_changed`) ensure downstream status and UIs reflect the updated working coordinate offset.

## New limits system (tool + work area)

- Centralized: Soft-limit enforcement is unified in Limits; calibration and pen changes use “system motion” and special routing so measured limit trips don’t raise alarms.
- Safety: Hard limits remain authoritative.

Code (route limit trips to calibration instead of alarms)

```cpp
// Protocol.cpp
static void protocol_do_limit(void* arg) {
  Machine::LimitPin* limit = (Machine::LimitPin*)arg;
  if (state_is(State::Homing)) { Machine::Homing::limitReached(); return; }
  if (ToolCalibration::isCalibrating()) { ToolCalibration::onLimit(limit); return; }
  if (WorkAreaCalibration::isRunning()) { WorkAreaCalibration::onLimit(limit); return; }
  if ((state_is(State::Cycle) || state_is(State::Jog) || state_is(State::Idle) || state_is(State::Hold) || state_is(State::SafetyDoor)) &&
      limit->isHard()) {
    mc_critical(ExecAlarm::HardLimit);
  }
}
```

How it works

- State-aware routing: `protocol_do_limit` first checks Homing, then ToolCalibration, then WorkAreaCalibration. Only if none are active does it consider normal alarm paths.
- Soft vs hard limits: Calibration uses system-motion semantics to bypass soft-limit prechecks for the specific queued moves, but if a real “hard” limit is encountered (per machine config), an alarm is still raised to protect hardware.
- Abort paths: Real-time reset cancels calibration cleanly by stopping steppers, resetting state to Idle, and leaving the machine ready for the next command.

## UI streaming (standalone JS/CSS)

- Build: UI supports separate JS/CSS during development and gz/minified packaging.
- Serving: Web server sets proper MIME types and `Content-Encoding: gzip`, with ETag caching. During active jobs, heavy SD access is gated; a minimal `/jobcontrol` UI is served.

Code (selected endpoints)

```cpp
// WebServer.cpp (selected)
_webserver->on("/jobcontrol", HTTP_GET, [this]() { /* serves minimal control page */ });
_webserver->on("/jobstatus", HTTP_GET, [this]() { /* JSON status */ });
_webserver->on("/toolconfig", HTTP_GET, handleGetToolConfig);
_webserver->on("/toolconfig", HTTP_POST, handleSetToolConfig);
_webserver->on("/workorigin", HTTP_GET, [this]() { /* origin info */ });
_webserver->on("/restart", HTTP_ANY, [this]() { /* restart MCU */ });
```

## G-code dry run (check mode)

- Behavior: Parses/plans without moving motors so you can verify paths and limits.
- Use: Toggle FluidNC check mode (standard `$C`) to enter/exit dry run.

## Tool change (M6) details

Code (execution path and motion parameters)

```cpp
// GCode.cpp (M6 execution)
if (gc_block.modal.tool_change == ToolChange::Enable) {
  auto& toolConfig = WebUI::ToolConfig::getInstance();
  if (!toolConfig.ensureLoaded()) return Error::GcodeToolChangeFailed;

  memset(pl_data, 0, sizeof(plan_line_data_t));
  pl_data->prevPenNumber         = gc_state.prev_tool;
  pl_data->penNumber             = gc_state.tool;
  pl_data->feed_rate             = 10000.0f;
  pl_data->approach_feedrate     = 8000.0f;
  pl_data->precise_feedrate      = 2000.0f;
  pl_data->line_number           = gc_block.values.n;
  pl_data->motion.noFeedOverride = 1;
  pl_data->motion.rapidMotion    = 1;

  protocol_buffer_synchronize();
  if (!mc_pen_change(pl_data)) {
    gc_state.tool = gc_state.prev_tool;  // rollback on failure
    return Error::GcodeToolChangeFailed;
  }
  gc_block.modal.tool_change = ToolChange::Disable;
  gc_state.prev_tool         = gc_state.tool;
}
```

How it works

- Configuration readiness: The routine ensures tool configuration is loaded (via `ToolConfig::ensureLoaded()`), aborting with a clear error if persistence is unavailable or invalid.
- Planned system motion: It programs distinct approach vs precise feedrates and disables feed overrides for deterministic, reproducible pen-change travel.
- Buffer discipline: It synchronizes the planner buffer before invoking `mc_pen_change(...)` so the motion starts from a known, clean queue state.
- Failure handling: If any step in the pen-change flow fails, the current tool is rolled back to the previous tool and the modal tool-change flag is cleared to leave the parser consistent.
- Limits interaction: During the change, motions follow the central limits model; soft-limit interactions are coordinated to avoid spurious alarms while still honoring hard limits.

## Work area toggles (M160/M161)

Code

```cpp
// GCode.cpp
case 160: config->enableWorkArea();  break;  // enable soft-limits based on work_area
case 161: config->disableWorkArea(); break;  // disable
```

## Tool bank persistence (JSON)

Code (serialize/deserialize, last tool state)

```cpp
// WebUI/ToolConfig.cpp
std::string ToolConfig::toJSON() {
  JSONencoder j(&output);
  j.begin(); j.begin_array("tools");
  for (const auto& tool : tools) {
    j.begin_object();
    j.member("number", std::to_string(tool.number).c_str());
    j.member("x", std::to_string(tool.x).c_str());
    j.member("y", std::to_string(tool.y).c_str());
    j.member("z", std::to_string(tool.z).c_str());
    j.member("occupied", tool.occupied ? "true" : "false");
    j.end_object();
  }
  j.end_array(); j.end();
}

bool ToolConfig::saveCurrentState(int currentPen) {
  FileStream file(stateFile, "w");
  JSONencoder j(&output);
  j.begin(); j.member("currentPen", std::to_string(currentPen).c_str());
  j.member("timestamp", std::to_string(esp_timer_get_time()).c_str());
  j.end();
  file.write(reinterpret_cast<const uint8_t*>(output.c_str()), output.length());
}
```

How it works

- JSON shape: `tools` is an array of objects with `{number, x, y, z, occupied}`. This keeps the model simple and extensible for future metadata (e.g., diameter, color).
- Serialization: `toJSON()` writes the full array on each save; `fromJSON()` rebuilds the in-memory list. A `sortByNumber()` utility keeps ordering predictable for UI display.
- State file: `saveCurrentState()` writes `currentPen` and a timestamp to `/spiffs/penstate.json` for recovery across resets or power cycles.
- Access patterns: UI uses `/toolconfig` GET/POST to read or replace the tool bank; a `/toolconfig/status` endpoint can expose occupancy/state for quick checks.
- Validation & safety: The module provides helpers to validate positions and check collision risks between pens, preventing unsafe moves during automated changes.

---
Related: See `CALIBRATION.md` for step-by-step instructions for M155/M156. This document is a high-level behavior summary.
